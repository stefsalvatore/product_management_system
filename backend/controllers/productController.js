const { Product, Category } = require('../models');
const { Op } = require('sequelize');
const fs = require('fs');
const path = require('path');
const csv = require('csv-parser');
const XLSX = require('xlsx');
const { createObjectCsvWriter } = require('csv-writer');

// Get all products with pagination, sorting, and search
exports.getAllProducts = async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const sortBy = req.query.sortBy || 'created_at';
    const order = (req.query.order || 'DESC').toUpperCase();
    const search = req.query.search || '';
    const category = req.query.category || '';

    const offset = (page - 1) * limit;
    const validSortColumns = ['name', 'price', 'created_at'];
    const sortColumn = validSortColumns.includes(sortBy) ? sortBy : 'created_at';

    // Build where clause
    const whereClause = {};
    if (search) {
      whereClause.name = { [Op.like]: `%${search}%` };
    }

    // Build category filter
    const categoryWhere = {};
    if (category) {
      categoryWhere.name = { [Op.like]: `%${category}%` };
    }

    // Get products with category info
    const { count, rows } = await Product.findAndCountAll({
      where: whereClause,
      include: [{
        model: Category,
        as: 'category',
        attributes: ['id', 'name', 'unique_id'],
        where: Object.keys(categoryWhere).length > 0 ? categoryWhere : undefined
      }],
      limit,
      offset,
      order: [[sortColumn, order]],
      distinct: true
    });

    // Format response to match frontend expectations
    const formattedRows = rows.map(product => ({
      id: product.id,
      unique_id: product.unique_id,
      name: product.name,
      image: product.image,
      price: product.price,
      category_id: product.category_id,
      category_name: product.category ? product.category.name : null,
      category_unique_id: product.category ? product.category.unique_id : null,
      created_at: product.created_at,
      updated_at: product.updated_at
    }));

    res.json({
      success: true,
      data: formattedRows,
      pagination: {
        total: count,
        page,
        limit,
        totalPages: Math.ceil(count / limit)
      }
    });
  } catch (error) {
    console.error('Get all products error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error',
      error: error.message
    });
  }
};

// Get product by ID
exports.getProductById = async (req, res) => {
  try {
    const product = await Product.findByPk(req.params.id, {
      include: [{
        model: Category,
        as: 'category',
        attributes: ['id', 'name', 'unique_id']
      }]
    });

    if (!product) {
      return res.status(404).json({
        success: false,
        message: 'Product not found'
      });
    }

    // Format response
    const formattedProduct = {
      id: product.id,
      unique_id: product.unique_id,
      name: product.name,
      image: product.image,
      price: product.price,
      category_id: product.category_id,
      category_name: product.category ? product.category.name : null,
      category_unique_id: product.category ? product.category.unique_id : null,
      created_at: product.created_at,
      updated_at: product.updated_at
    };

    res.json({
      success: true,
      data: formattedProduct
    });
  } catch (error) {
    console.error('Get product error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error',
      error: error.message
    });
  }
};

// Create product
exports.createProduct = async (req, res) => {
  try {
    const { name, price, category_id } = req.body;
    const image = req.file ? `/uploads/images/${req.file.filename}` : null;

    // Verify category exists
    const category = await Category.findByPk(category_id);
    if (!category) {
      return res.status(404).json({
        success: false,
        message: 'Category not found'
      });
    }

    // Create product (unique_id will be generated by beforeCreate hook)
    const product = await Product.create({
      name,
      image,
      price,
      category_id
    });

    res.status(201).json({
      success: true,
      message: 'Product created successfully',
      data: {
        id: product.id,
        unique_id: product.unique_id
      }
    });
  } catch (error) {
    console.error('Create product error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error',
      error: error.message
    });
  }
};

// Update product
exports.updateProduct = async (req, res) => {
  try {
    const { name, price, category_id } = req.body;

    const product = await Product.findByPk(req.params.id);
    if (!product) {
      return res.status(404).json({
        success: false,
        message: 'Product not found'
      });
    }

    const updateData = {};
    if (name !== undefined) updateData.name = name;
    if (price !== undefined) updateData.price = price;

    if (category_id !== undefined) {
      // Verify category exists
      const category = await Category.findByPk(category_id);
      if (!category) {
        return res.status(404).json({
          success: false,
          message: 'Category not found'
        });
      }
      updateData.category_id = category_id;
    }

    // Handle image update
    if (req.file) {
      updateData.image = `/uploads/images/${req.file.filename}`;

      // Delete old image
      if (product.image) {
        const oldImagePath = path.join(__dirname, '..', product.image);
        if (fs.existsSync(oldImagePath)) {
          fs.unlinkSync(oldImagePath);
        }
      }
    }

    await product.update(updateData);

    res.json({
      success: true,
      message: 'Product updated successfully'
    });
  } catch (error) {
    console.error('Update product error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error',
      error: error.message
    });
  }
};

// Delete product
exports.deleteProduct = async (req, res) => {
  try {
    const product = await Product.findByPk(req.params.id);
    if (!product) {
      return res.status(404).json({
        success: false,
        message: 'Product not found'
      });
    }

    // Delete image file
    if (product.image) {
      const imagePath = path.join(__dirname, '..', product.image);
      if (fs.existsSync(imagePath)) {
        fs.unlinkSync(imagePath);
      }
    }

    await product.destroy();

    res.json({
      success: true,
      message: 'Product deleted successfully'
    });
  } catch (error) {
    console.error('Delete product error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error',
      error: error.message
    });
  }
};

// Bulk upload products
exports.bulkUpload = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No file uploaded'
      });
    }

    const filePath = req.file.path;
    const fileExt = path.extname(req.file.originalname).toLowerCase();
    const products = [];

    // Parse file based on extension
    if (fileExt === '.csv') {
      await new Promise((resolve, reject) => {
        fs.createReadStream(filePath)
          .pipe(csv())
          .on('data', (row) => {
            products.push({
              name: row.name || row.Name,
              price: parseFloat(row.price || row.Price),
              category_id: parseInt(row.category_id || row.CategoryID || row.category_id),
              image: row.image || row.Image || null
            });
          })
          .on('end', resolve)
          .on('error', reject);
      });
    } else if (fileExt === '.xlsx') {
      const workbook = XLSX.readFile(filePath);
      const sheetName = workbook.SheetNames[0];
      const sheet = workbook.Sheets[sheetName];
      const data = XLSX.utils.sheet_to_json(sheet);

      data.forEach((row) => {
        products.push({
          name: row.name || row.Name,
          price: parseFloat(row.price || row.Price),
          category_id: parseInt(row.category_id || row.CategoryID || row.category_id),
          image: row.image || row.Image || null
        });
      });
    } else {
      fs.unlinkSync(filePath);
      return res.status(400).json({
        success: false,
        message: 'Unsupported file format. Use CSV or XLSX'
      });
    }

    // Validate products
    const validProducts = [];
    const errors = [];

    for (let i = 0; i < products.length; i++) {
      const product = products[i];

      if (!product.name || !product.price || !product.category_id) {
        errors.push(`Row ${i + 1}: Missing required fields`);
        continue;
      }

      if (isNaN(product.price) || product.price < 0) {
        errors.push(`Row ${i + 1}: Invalid price`);
        continue;
      }

      // Verify category exists
      const category = await Category.findByPk(product.category_id);
      if (!category) {
        errors.push(`Row ${i + 1}: Category ID ${product.category_id} not found`);
        continue;
      }

      validProducts.push(product);
    }

    // Bulk insert in batches
    const batchSize = 1000;
    let totalInserted = 0;

    for (let i = 0; i < validProducts.length; i += batchSize) {
      const batch = validProducts.slice(i, i + batchSize);
      await Product.bulkCreate(batch);
      totalInserted += batch.length;
    }

    // Delete uploaded file
    fs.unlinkSync(filePath);

    res.json({
      success: true,
      message: 'Bulk upload completed',
      data: {
        totalRows: products.length,
        inserted: totalInserted,
        failed: products.length - validProducts.length,
        errors: errors.slice(0, 10)
      }
    });
  } catch (error) {
    console.error('Bulk upload error:', error);
    if (req.file && fs.existsSync(req.file.path)) {
      fs.unlinkSync(req.file.path);
    }
    res.status(500).json({
      success: false,
      message: 'Server error during bulk upload',
      error: error.message
    });
  }
};

// Export products to CSV/XLSX
exports.exportProducts = async (req, res) => {
  try {
    const format = req.query.format || 'csv';
    const search = req.query.search || '';
    const category = req.query.category || '';

    // Build where clause
    const whereClause = {};
    if (search) {
      whereClause.name = { [Op.like]: `%${search}%` };
    }

    const categoryWhere = {};
    if (category) {
      categoryWhere.name = { [Op.like]: `%${category}%` };
    }

    // Get all products
    const products = await Product.findAll({
      where: whereClause,
      include: [{
        model: Category,
        as: 'category',
        attributes: ['name', 'unique_id'],
        where: Object.keys(categoryWhere).length > 0 ? categoryWhere : undefined
      }],
      order: [['created_at', 'DESC']]
    });

    // Format data for export
    const exportData = products.map(p => ({
      unique_id: p.unique_id,
      name: p.name,
      price: p.price,
      category_name: p.category ? p.category.name : '',
      category_unique_id: p.category ? p.category.unique_id : '',
      image: p.image || '',
      created_at: p.created_at,
      updated_at: p.updated_at
    }));

    if (format === 'csv') {
      const csvPath = path.join(__dirname, '..', 'uploads', `products-${Date.now()}.csv`);

      const csvWriter = createObjectCsvWriter({
        path: csvPath,
        header: [
          { id: 'unique_id', title: 'UniqueID' },
          { id: 'name', title: 'Name' },
          { id: 'price', title: 'Price' },
          { id: 'category_name', title: 'Category' },
          { id: 'category_unique_id', title: 'CategoryUniqueID' },
          { id: 'image', title: 'Image' },
          { id: 'created_at', title: 'CreatedAt' },
          { id: 'updated_at', title: 'UpdatedAt' }
        ]
      });

      await csvWriter.writeRecords(exportData);

      res.download(csvPath, 'products.csv', (err) => {
        if (err) console.error('Download error:', err);
        fs.unlinkSync(csvPath);
      });
    } else if (format === 'xlsx') {
      const worksheet = XLSX.utils.json_to_sheet(exportData);
      const workbook = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(workbook, worksheet, 'Products');

      const xlsxPath = path.join(__dirname, '..', 'uploads', `products-${Date.now()}.xlsx`);
      XLSX.writeFile(workbook, xlsxPath);

      res.download(xlsxPath, 'products.xlsx', (err) => {
        if (err) console.error('Download error:', err);
        fs.unlinkSync(xlsxPath);
      });
    } else {
      return res.status(400).json({
        success: false,
        message: 'Invalid format. Use csv or xlsx'
      });
    }
  } catch (error) {
    console.error('Export products error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error during export',
      error: error.message
    });
  }
};
